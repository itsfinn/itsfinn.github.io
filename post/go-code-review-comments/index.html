<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.82.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Go Code Review Comments - itsfinn&#39;s blog.</title>
    <meta property="og:title" content="Go Code Review Comments - itsfinn&#39;s blog.">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2021-04-18T13:04:21&#43;08:00">
        
        
    <meta property="article:modified_time" content="2021-04-18T13:04:21&#43;08:00">
        
    <meta name="description" content="本页面收集了Go代码评审的常见评论。并提供了简单的细节解释，可以代码评审时引用。这只是一个常见错误的列表，并不是一个全面的风格指南。你可以把这些当作对 [Effective Go](https://golang.org/doc/effective_go.html)的补充.">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://itsfinn.cc/post/go-code-review-comments/">

    <link rel="stylesheet" href="/css/normalize.css">
    
    <link rel="stylesheet" href="/css/syntax.css">
    
    <link rel="stylesheet" href="/css/style.css">

    </head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://itsfinn.cc/">
                        itsfinn&#39;s blog.
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://itsfinn.cc/">博客</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">Go Code Review Comments</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2021年4月18日
                            13:04
                        </date>
                        
                        <div class="post-meta meta-category">
                            ，归类于
                            
                                <a href="/categories/go">Go</a>
                            
                        </div>
                        <aside id="toc" class="dismissed">
                            <span class="toc-title">目录 <a href="#" class="toc-dismiss"></a></span>
                            <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#gofmt">Gofmt</a></li>
        <li><a href="#注释应该是句子">注释应该是句子</a></li>
        <li><a href="#contexts">Contexts</a></li>
        <li><a href="#复制">复制</a></li>
        <li><a href="#crypto-rand">Crypto Rand</a></li>
        <li><a href="#declaring-empty-slices">Declaring Empty Slices</a></li>
        <li><a href="#doc-comments">Doc Comments</a></li>
        <li><a href="#dont-panic">Don&rsquo;t Panic</a></li>
        <li><a href="#error-strings">Error Strings</a></li>
        <li><a href="#examples">Examples</a></li>
        <li><a href="#goroutine-lifetimes">Goroutine Lifetimes</a></li>
        <li><a href="#handle-errors">Handle Errors</a></li>
        <li><a href="#imports">Imports</a></li>
        <li><a href="#import-blank">Import Blank</a></li>
        <li><a href="#import-dot">Import Dot</a></li>
        <li><a href="#in-band-errors">In-Band Errors</a></li>
        <li><a href="#indent-error-flow">Indent Error Flow</a></li>
        <li><a href="#initialisms">Initialisms</a></li>
        <li><a href="#interfaces">Interfaces</a></li>
        <li><a href="#line-length">Line Length</a></li>
        <li><a href="#mixed-caps">Mixed Caps</a></li>
        <li><a href="#named-result-parameters">Named Result Parameters</a></li>
        <li><a href="#naked-returns">Naked Returns</a></li>
        <li><a href="#package-comments">Package Comments</a></li>
        <li><a href="#package-names">Package Names</a></li>
        <li><a href="#pass-values">Pass Values</a></li>
        <li><a href="#receiver-names">Receiver Names</a></li>
        <li><a href="#receiver-type">Receiver Type</a></li>
        <li><a href="#synchronous-functions">Synchronous Functions</a></li>
        <li><a href="#useful-test-failures">Useful Test Failures</a></li>
        <li><a href="#variable-names">Variable Names</a></li>
      </ul>
    </li>
  </ul>
</nav>
                        </aside><div class="post-content">
                            <p>原文地址：https://github.com/golang/go/wiki/CodeReviewComments</p>
<ul>
<li><a href="#gofmt">Gofmt</a></li>
<li><a href="#%E5%A3%B0%E6%98%8E%E7%9A%84%E6%B3%A8%E9%87%8A%E5%BA%94%E8%AF%A5%E6%98%AF%E5%8F%A5%E5%AD%90">声明的注释应该是句子</a></li>
<li><a href="#contexts">Contexts</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6">复制</a></li>
<li><a href="#crypto-rand">Crypto Rand</a></li>
<li><a href="#declaring-empty-slices">声明空数组</a></li>
<li><a href="#doc-comments">文档注释</a></li>
<li><a href="#dont-panic">不要使用panic</a></li>
<li><a href="#error-strings">Error Strings</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#goroutine-lifetimes">Goroutine Lifetimes</a></li>
<li><a href="#handle-errors">Handle Errors</a></li>
<li><a href="#imports">Imports</a></li>
<li><a href="#import-blank">Import Blank</a></li>
<li><a href="#import-dot">Import Dot</a></li>
<li><a href="#in-band-errors">In-Band Errors</a></li>
<li><a href="#indent-error-flow">Indent Error Flow</a></li>
<li><a href="#initialisms">Initialisms</a></li>
<li><a href="#interfaces">Interfaces</a></li>
<li><a href="#line-length">Line Length</a></li>
<li><a href="#mixed-caps">Mixed Caps</a></li>
<li><a href="#named-result-parameters">Named Result Parameters</a></li>
<li><a href="#naked-returns">Naked Returns</a></li>
<li><a href="#package-comments">Package Comments</a></li>
<li><a href="#package-names">Package Names</a></li>
<li><a href="#pass-values">Pass Values</a></li>
<li><a href="#receiver-names">Receiver Names</a></li>
<li><a href="#receiver-type">Receiver Type</a></li>
<li><a href="#synchronous-functions">Synchronous Functions</a></li>
<li><a href="#useful-test-failures">Useful Test Failures</a></li>
<li><a href="#variable-names">Variable Names</a></li>
</ul>
<h2 id="gofmt">Gofmt</h2>
<p>在你的代码上运行<a href="https://golang.org/cmd/gofmt/">gofmt</a>可以解决大多数固定的代码风格问题。几乎所有的Go代码都在使用 <code>gofmt</code>。本文档的其他部分会讨论非固定格式的代码风格问题。</p>
<p>你也可以使用<a href="https://godoc.org/golang.org/x/tools/cmd/goimports">goimports</a>, 它是 <code>gofmt</code> 的超集，可以根据需要添加或删除 import 行。</p>
<h2 id="注释应该是句子">注释应该是句子</h2>
<p>参见 <a href="https://golang.org/doc/effective_go.html#commentary">https://golang.org/doc/effective_go.html#commentary</a> 。针对声明的代码注释应该是完整的句子，即使它看起来有些多余。 这样你生成 godoc 文档可读性更好。注释应该以所描述事物的名称开始，并以句号结束:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Request represents a request to run a command.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Request</span> <span class="kd">struct</span> <span class="p">{</span> <span class="o">...</span>

<span class="c1">// Encode writes the JSON encoding of req to w.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Encode</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="contexts">Contexts</h2>
<p><code>context.Context</code> 类型的 Value 可以携带跨越API或处理逻辑边界的安全凭据，追踪信息，截止日期或取消信号。在 Go 程序里，Context 显式地在整个函数调用链中传递，从接受 RPC 或者 HTTP 调用，一直到对外的 RPC 或者 HTTP 调用。</p>
<p>大多数使用Context的函数，都应该把它作为第一个参数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">F</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="cm">/* other arguments */</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>A function that is never request-specific may use context.Background(),
but err on the side of passing a Context even if you think you don&rsquo;t need
to. The default case is to pass a Context; only use context.Background()
directly if you have a good reason why the alternative is a mistake.</p>
<p>Don&rsquo;t add a Context member to a struct type; instead add a ctx parameter
to each method on that type that needs to pass it along. The one exception
is for methods whose signature must match an interface in the standard library
or in a third party library.</p>
<p>Don&rsquo;t create custom Context types or use interfaces other than Context in function signatures.</p>
<p>If you have application data to pass around, put it in a parameter,
in the receiver, in globals, or, if it truly belongs there, in a Context value.</p>
<p>上下文是不可变的，所以可以放心把同一个ctx传递给多个调用，如果这些调用共享截止时间，取消信号，凭证，追踪信息等。</p>
<h2 id="复制">复制</h2>
<p>为了避免意外的别名，在从另一个 package 复制结构时，要尤其小心。 例如，bytes.Buffer 类型包含一个 <code>[]byte</code> 切片。如果你复制一个 <code>Buffer</code>， 副本中的切片只是原始数组的别名，从而导致后续方法调用可能会有意外的效果。 一般来说，如果类型 <code>T</code> 的方法，关联的是它的指针类型 <code>*T</code> ，那么不要复制 <code>T</code> 的值。</p>
<h2 id="crypto-rand">Crypto Rand</h2>
<p>不要使用 <code>math/rand</code> 来生成密钥，即使是一次性的密钥。 在没有种子的情况下，生成的密钥是完全可以预测的。使用 <code>time.Nanoseconds()</code> 作为种子，也只带来少量的熵。你应该使用 <code>crypto/rand</code> 的 Reader， 如果需要的是文本，可以打印为十六进制或base64:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;crypto/rand&#34;</span>
	<span class="c1">// &#34;encoding/base64&#34;
</span><span class="c1"></span>	<span class="c1">// &#34;encoding/hex&#34;
</span><span class="c1"></span>	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">Key</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>  <span class="c1">// out of randomness, should never happen
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%x&#34;</span><span class="p">,</span> <span class="nx">buf</span><span class="p">)</span>
	<span class="c1">// or hex.EncodeToString(buf)
</span><span class="c1"></span>	<span class="c1">// or base64.StdEncoding.EncodeToString(buf)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="declaring-empty-slices">Declaring Empty Slices</h2>
<p>当你创建空数组时推荐使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">t</span> <span class="p">[]</span><span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>而不是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">t</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>前者是一个值为nil的切片。后者只是长度为零，但不是nil。他们在功能上是完全相同的。他们的 <code>len</code> and <code>cap</code>都是零，但是nil切片是更加推荐的方式。</p>
<p>请注意，在有些特殊情况，更推荐使用不为nil，但长度为零但切片，例如编码
JSON对象但时候（一个<code>nil</code>切片被编码成<code>null</code>，但是<code>[]string{}</code>被比编码成JSON数组<code>[]</code>）。</p>
<p>在设计接口时，避免区分nil片和非nil、零长度的片，因为这可能会导致微妙的编程错误。</p>
<p>When designing interfaces, avoid making a distinction between a nil slice and a non-nil, zero-length slice, as this can lead to subtle programming errors.</p>
<p>Go中关于nil的更多讨论可以看一下 Francesc Campoy 的视频 <a href="https://www.youtube.com/watch?v=ynoY2xz-F8s">Understanding Nil</a>.</p>
<h2 id="doc-comments">Doc Comments</h2>
<p>所有顶级的、可导出的名称，都应该有文档注释，重要的未导出类型或函数声明也应该如此。有关注释约定的更多信息，请参见https://golang.org/doc/effective_go.html#commentary。</p>
<h2 id="dont-panic">Don&rsquo;t Panic</h2>
<p>参见 <a href="https://golang.org/doc/effective_go.html#errors">https://golang.org/doc/effective_go.html#errors</a>. 对于正常的错误处理，不要使用panic。使用错误和多个返回值。</p>
<h2 id="error-strings">Error Strings</h2>
<p>错误字符串不应该大写(除非以专有名词或首字母缩写开头)，也不应该以标点符号结尾，因为它们通常在其他上下文后面打印。也就是说，使用 <code>fmt.Errorf(&quot;something bad&quot;)</code> 而不是<code>fmt.Errorf(&quot;Something bad.&quot;)</code>，这样 <code>log.Printf(&quot;Reading %s: %v&quot;, filename, err)</code> 的输出才不会出现大写字母。不过这不适用于日志记录，日志记录是隐式面向行的，不会在其他消息中合并。</p>
<h2 id="examples">Examples</h2>
<p>添加新的 package 时，同时添加一些使用示例，这些示例应该是可运行的，或者一个可以演示的，包含了完整调用过程的测试用例。更多内容参见 <a href="https://blog.golang.org/examples">testable Example() functions</a>.</p>
<h2 id="goroutine-lifetimes">Goroutine Lifetimes</h2>
<p>When you spawn goroutines, make it clear when - or whether - they exit.</p>
<p>Goroutines can leak by blocking on channel sends or receives: the garbage collector
will not terminate a goroutine even if the channels it is blocked on are unreachable.</p>
<p>Even when goroutines do not leak, leaving them in-flight when they are no longer
needed can cause other subtle and hard-to-diagnose problems. Sends on closed channels
panic. Modifying still-in-use inputs &ldquo;after the result isn&rsquo;t needed&rdquo; can still lead
to data races. And leaving goroutines in-flight for arbitrarily long can lead to
unpredictable memory usage.</p>
<p>Try to keep concurrent code simple enough that goroutine lifetimes are obvious.
If that just isn&rsquo;t feasible, document when and why the goroutines exit.</p>
<h2 id="handle-errors">Handle Errors</h2>
<p>See <a href="https://golang.org/doc/effective_go.html#errors">https://golang.org/doc/effective_go.html#errors</a>. Do not discard errors using <code>_</code> variables. If a function returns an error, check it to make sure the function succeeded. Handle the error, return it, or, in truly exceptional situations, panic.</p>
<h2 id="imports">Imports</h2>
<p>Avoid renaming imports except to avoid a name collision; good package names
should not require renaming. In the event of collision, prefer to rename the most
local or project-specific import.</p>
<p>Imports are organized in groups, with blank lines between them.
The standard library packages are always in the first group.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;hash/adler32&#34;</span>
	<span class="s">&#34;os&#34;</span>

	<span class="s">&#34;appengine/foo&#34;</span>
	<span class="s">&#34;appengine/user&#34;</span>

	<span class="s">&#34;github.com/foo/bar&#34;</span>
	<span class="s">&#34;rsc.io/goversion/version&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><!-- raw HTML omitted -->goimports<!-- raw HTML omitted --> will do this for you.</p>
<h2 id="import-blank">Import Blank</h2>
<p>Packages that are imported only for their side effects (using the syntax <code>import _ &quot;pkg&quot;</code>) should only be imported in the main package of a program, or in tests
that require them.</p>
<h2 id="import-dot">Import Dot</h2>
<p>The import . form can be useful in tests that, due to circular dependencies, cannot be made part of the package being tested:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">foo_test</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bar/testutil&#34;</span> <span class="c1">// also imports &#34;foo&#34;
</span><span class="c1"></span>	<span class="p">.</span> <span class="s">&#34;foo&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>In this case, the test file cannot be in package foo because it uses bar/testutil, which imports foo.  So we use the &lsquo;import .&rsquo; form to let the file pretend to be part of package foo even though it is not.  Except for this one case, do not use import . in your programs.  It makes the programs much harder to read because it is unclear whether a name like Quux is a top-level identifier in the current package or in an imported package.</p>
<h2 id="in-band-errors">In-Band Errors</h2>
<p>In C and similar languages, it&rsquo;s common for functions to return values like -1
or null to signal errors or missing results:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Lookup returns the value for key or &#34;&#34; if there is no mapping for key.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Lookup</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>

<span class="c1">// Failing to check a for an in-band error value can lead to bugs:
</span><span class="c1"></span><span class="nf">Parse</span><span class="p">(</span><span class="nf">Lookup</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>  <span class="c1">// returns &#34;parse failure for value&#34; instead of &#34;no value for key&#34;
</span></code></pre></td></tr></table>
</div>
</div><p>Go&rsquo;s support for multiple return values provides a better solution.
Instead of requiring clients to check for an in-band error value, a function should return
an additional value to indicate whether its other return values are valid. This return
value may be an error, or a boolean when no explanation is needed.
It should be the final return value.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Lookup returns the value for key or ok=false if there is no mapping for key.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Lookup</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>This prevents the caller from using the result incorrectly:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">Parse</span><span class="p">(</span><span class="nf">Lookup</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>  <span class="c1">// compile-time error
</span></code></pre></td></tr></table>
</div>
</div><p>And encourages more robust and readable code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">Lookup</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;no value for %q&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nf">Parse</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>This rule applies to exported functions but is also useful
for unexported functions.</p>
<p>Return values like nil, &ldquo;&rdquo;, 0, and -1 are fine when they are
valid results for a function, that is, when the caller need not
handle them differently from other values.</p>
<p>Some standard library functions, like those in package &ldquo;strings&rdquo;,
return in-band error values. This greatly simplifies string-manipulation
code at the cost of requiring more diligence from the programmer.
In general, Go code should return additional values for errors.</p>
<h2 id="indent-error-flow">Indent Error Flow</h2>
<p>Try to keep the normal code path at a minimal indentation, and indent the error handling, dealing with it first. This improves the readability of the code by permitting visually scanning the normal path quickly. For instance, don&rsquo;t write:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="c1">// error handling
</span><span class="c1"></span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="c1">// normal code
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Instead, write:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="c1">// error handling
</span><span class="c1"></span>	<span class="k">return</span> <span class="c1">// or continue, etc.
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// normal code
</span></code></pre></td></tr></table>
</div>
</div><p>If the <code>if</code> statement has an initialization statement, such as:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">f</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="c1">// error handling
</span><span class="c1"></span>	<span class="k">return</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="c1">// use x
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>then this may require moving the short variable declaration to its own line:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">x</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">f</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="c1">// error handling
</span><span class="c1"></span>	<span class="k">return</span>
<span class="p">}</span>
<span class="c1">// use x
</span></code></pre></td></tr></table>
</div>
</div><h2 id="initialisms">Initialisms</h2>
<p>Words in names that are initialisms or acronyms (e.g. &ldquo;URL&rdquo; or &ldquo;NATO&rdquo;) have a consistent case. For example, &ldquo;URL&rdquo; should appear as &ldquo;URL&rdquo; or &ldquo;url&rdquo; (as in &ldquo;urlPony&rdquo;, or &ldquo;URLPony&rdquo;), never as &ldquo;Url&rdquo;. As an example: ServeHTTP not ServeHttp. For identifiers with multiple initialized &ldquo;words&rdquo;, use for example &ldquo;xmlHTTPRequest&rdquo; or &ldquo;XMLHTTPRequest&rdquo;.</p>
<p>This rule also applies to &ldquo;ID&rdquo; when it is short for &ldquo;identifier&rdquo; (which is pretty much all cases when it&rsquo;s not the &ldquo;id&rdquo; as in &ldquo;ego&rdquo;, &ldquo;superego&rdquo;), so write &ldquo;appID&rdquo; instead of &ldquo;appId&rdquo;.</p>
<p>Code generated by the protocol buffer compiler is exempt from this rule. Human-written code is held to a higher standard than machine-written code.</p>
<h2 id="interfaces">Interfaces</h2>
<p>Go interfaces generally belong in the package that uses values of the
interface type, not the package that implements those values. The
implementing package should return concrete (usually pointer or struct)
types: that way, new methods can be added to implementations without
requiring extensive refactoring.</p>
<p>Do not define interfaces on the implementor side of an API &ldquo;for mocking&rdquo;;
instead, design the API so that it can be tested using the public API of
the real implementation.</p>
<p>Do not define interfaces before they are used: without a realistic example
of usage, it is too difficult to see whether an interface is even necessary,
let alone what methods it ought to contain.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">consumer</span>  <span class="c1">// consumer.go
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Thinger</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">Thing</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">Foo</span><span class="p">(</span><span class="nx">t</span> <span class="nx">Thinger</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">consumer</span> <span class="c1">// consumer_test.go
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">fakeThinger</span> <span class="kd">struct</span><span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">fakeThinger</span><span class="p">)</span> <span class="nf">Thing</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
<span class="err">…</span>
<span class="k">if</span> <span class="nf">Foo</span><span class="p">(</span><span class="nx">fakeThinger</span><span class="p">{</span><span class="err">…</span><span class="p">})</span> <span class="o">==</span> <span class="s">&#34;x&#34;</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// DO NOT DO IT!!!
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">producer</span>

<span class="kd">type</span> <span class="nx">Thinger</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">Thing</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">defaultThinger</span> <span class="kd">struct</span><span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">defaultThinger</span><span class="p">)</span> <span class="nf">Thing</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewThinger</span><span class="p">()</span> <span class="nx">Thinger</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">defaultThinger</span><span class="p">{</span> <span class="err">…</span> <span class="p">}</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Instead return a concrete type and let the consumer mock the producer implementation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">producer</span>

<span class="kd">type</span> <span class="nx">Thinger</span> <span class="kd">struct</span><span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Thinger</span><span class="p">)</span> <span class="nf">Thing</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewThinger</span><span class="p">()</span> <span class="nx">Thinger</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Thinger</span><span class="p">{</span> <span class="err">…</span> <span class="p">}</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="line-length">Line Length</h2>
<p>There is no rigid line length limit in Go code, but avoid uncomfortably long lines.
Similarly, don&rsquo;t add line breaks to keep lines short when they are more readable long&ndash;for example,
if they are repetitive.</p>
<p>Most of the time when people wrap lines &ldquo;unnaturally&rdquo; (in the middle of function calls or
function declarations, more or less, say, though some exceptions are around), the wrapping would be
unnecessary if they had a reasonable number of parameters and reasonably short variable names.
Long lines seem to go with long names, and getting rid of the long names helps a lot.</p>
<p>In other words, break lines because of the semantics of what you&rsquo;re writing (as a general rule)
and not because of the length of the line. If you find that this produces lines that are too long,
then change the names or the semantics and you&rsquo;ll probably get a good result.</p>
<p>This is, actually, exactly the same advice about how long a function should be. There&rsquo;s no rule
&ldquo;never have a function more than N lines long&rdquo;, but there is definitely such a thing as too long
of a function, and of too stuttery tiny functions, and the solution is to change where the function
boundaries are, not to start counting lines.</p>
<h2 id="mixed-caps">Mixed Caps</h2>
<p>See <a href="https://golang.org/doc/effective_go.html#mixed-caps">https://golang.org/doc/effective_go.html#mixed-caps</a>. This applies even when it breaks conventions in other languages. For example an unexported constant is <code>maxLength</code> not <code>MaxLength</code> or <code>MAX_LENGTH</code>.</p>
<p>Also see <a href="https://github.com/golang/go/wiki/CodeReviewComments#initialisms">Initialisms</a>.</p>
<h2 id="named-result-parameters">Named Result Parameters</h2>
<p>Consider what it will look like in godoc.  Named result parameters like:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="nf">Parent1</span><span class="p">()</span> <span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="nf">Parent2</span><span class="p">()</span> <span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>will stutter in godoc; better to use:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="nf">Parent1</span><span class="p">()</span> <span class="o">*</span><span class="nx">Node</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="nf">Parent2</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>On the other hand, if a function returns two or three parameters of the same type,
or if the meaning of a result isn&rsquo;t clear from context, adding names may be useful
in some contexts. Don&rsquo;t name result parameters just to avoid declaring a var inside
the function; that trades off a minor implementation brevity at the cost of
unnecessary API verbosity.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Foo</span><span class="p">)</span> <span class="nf">Location</span><span class="p">()</span> <span class="p">(</span><span class="kt">float64</span><span class="p">,</span> <span class="kt">float64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>is less clear than:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Location returns f&#39;s latitude and longitude.
</span><span class="c1">// Negative values mean south and west, respectively.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Foo</span><span class="p">)</span> <span class="nf">Location</span><span class="p">()</span> <span class="p">(</span><span class="nx">lat</span><span class="p">,</span> <span class="nx">long</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Naked returns are okay if the function is a handful of lines. Once it&rsquo;s a medium
sized function, be explicit with your return values. Corollary: it&rsquo;s not worth it
to name result parameters just because it enables you to use naked returns.
Clarity of docs is always more important than saving a line or two in your function.</p>
<p>Finally, in some cases you need to name a result parameter in order to change
it in a deferred closure. That is always OK.</p>
<h2 id="naked-returns">Naked Returns</h2>
<p>See <a href="#named-result-parameters">Named Result Parameters</a>.</p>
<h2 id="package-comments">Package Comments</h2>
<p>Package comments, like all comments to be presented by godoc, must appear adjacent to the package clause, with no blank line.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Package math provides basic constants and mathematical functions.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">math</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="cm">/*
</span><span class="cm">Package template implements data-driven templates for generating textual
</span><span class="cm">output such as HTML.
</span><span class="cm">....
</span><span class="cm">*/</span>
<span class="kn">package</span> <span class="nx">template</span>
</code></pre></td></tr></table>
</div>
</div><p>For &ldquo;package main&rdquo; comments, other styles of comment are fine after the binary name (and it may be capitalized if it comes first), For example, for a <code>package main</code> in the directory <code>seedgen</code> you could write:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Binary seedgen ...
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</code></pre></td></tr></table>
</div>
</div><p>or</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Command seedgen ...
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</code></pre></td></tr></table>
</div>
</div><p>or</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Program seedgen ...
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</code></pre></td></tr></table>
</div>
</div><p>or</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The seedgen command ...
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</code></pre></td></tr></table>
</div>
</div><p>or</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The seedgen program ...
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</code></pre></td></tr></table>
</div>
</div><p>or</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Seedgen ..
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</code></pre></td></tr></table>
</div>
</div><p>These are examples, and sensible variants of these are acceptable.</p>
<p>Note that starting the sentence with a lower-case word is not among the
acceptable options for package comments, as these are publicly-visible and
should be written in proper English, including capitalizing the first word
of the sentence. When the binary name is the first word, capitalizing it is
required even though it does not strictly match the spelling of the
command-line invocation.</p>
<p>See <a href="https://golang.org/doc/effective_go.html#commentary">https://golang.org/doc/effective_go.html#commentary</a> for more information about commentary conventions.</p>
<h2 id="package-names">Package Names</h2>
<p>All references to names in your package will be done using the package name,
so you can omit that name from the identifiers. For example, if you are in package chubby,
you don&rsquo;t need type ChubbyFile, which clients will write as <code>chubby.ChubbyFile</code>.
Instead, name the type <code>File</code>, which clients will write as <code>chubby.File</code>.
Avoid meaningless package names like util, common, misc, api, types, and interfaces. See <a href="http://golang.org/doc/effective_go.html#package-names">http://golang.org/doc/effective_go.html#package-names</a> and
<a href="http://blog.golang.org/package-names">http://blog.golang.org/package-names</a> for more.</p>
<h2 id="pass-values">Pass Values</h2>
<p>Don&rsquo;t pass pointers as function arguments just to save a few bytes.  If a function refers to its argument <code>x</code> only as <code>*x</code> throughout, then the argument shouldn&rsquo;t be a pointer.  Common instances of this include passing a pointer to a string (<code>*string</code>) or a pointer to an interface value (<code>*io.Reader</code>).  In both cases the value itself is a fixed size and can be passed directly.  This advice does not apply to large structs, or even small structs that might grow.</p>
<h2 id="receiver-names">Receiver Names</h2>
<p>The name of a method&rsquo;s receiver should be a reflection of its identity; often a one or two letter abbreviation of its type suffices (such as &ldquo;c&rdquo; or &ldquo;cl&rdquo; for &ldquo;Client&rdquo;). Don&rsquo;t use generic names such as &ldquo;me&rdquo;, &ldquo;this&rdquo; or &ldquo;self&rdquo;, identifiers typical of object-oriented languages that gives the method a special meaning. In Go, the receiver of a method is just another parameter and therefore, should be named accordingly. The name need not be as descriptive as that of a method argument, as its role is obvious and serves no documentary purpose. It can be very short as it will appear on almost every line of every method of the type; familiarity admits brevity. Be consistent, too: if you call the receiver &ldquo;c&rdquo; in one method, don&rsquo;t call it &ldquo;cl&rdquo; in another.</p>
<h2 id="receiver-type">Receiver Type</h2>
<p>Choosing whether to use a value or pointer receiver on methods can be difficult, especially to new Go programmers.  If in doubt, use a pointer, but there are times when a value receiver makes sense, usually for reasons of efficiency, such as for small unchanging structs or values of basic type. Some useful guidelines:</p>
<ul>
<li>If the receiver is a map, func or chan, don&rsquo;t use a pointer to them. If the receiver is a slice and the method doesn&rsquo;t reslice or reallocate the slice, don&rsquo;t use a pointer to it.</li>
<li>If the method needs to mutate the receiver, the receiver must be a pointer.</li>
<li>If the receiver is a struct that contains a sync.Mutex or similar synchronizing field, the receiver must be a pointer to avoid copying.</li>
<li>If the receiver is a large struct or array, a pointer receiver is more efficient.  How large is large?  Assume it&rsquo;s equivalent to passing all its elements as arguments to the method.  If that feels too large, it&rsquo;s also too large for the receiver.</li>
<li>Can function or methods, either concurrently or when called from this method, be mutating the receiver? A value type creates a copy of the receiver when the method is invoked, so outside updates will not be applied to this receiver. If changes must be visible in the original receiver, the receiver must be a pointer.</li>
<li>If the receiver is a struct, array or slice and any of its elements is a pointer to something that might be mutating, prefer a pointer receiver, as it will make the intention more clear to the reader.</li>
<li>If the receiver is a small array or struct that is naturally a value type (for instance, something like the time.Time type), with no mutable fields and no pointers, or is just a simple basic type such as int or string, a value receiver makes sense.  A value receiver can reduce the amount of garbage that can be generated; if a value is passed to a value method, an on-stack copy can be used instead of allocating on the heap. (The compiler tries to be smart about avoiding this allocation, but it can&rsquo;t always succeed.) Don&rsquo;t choose a value receiver type for this reason without profiling first.</li>
<li>Don&rsquo;t mix receiver types. Choose either pointers or struct types for all available methods.</li>
<li>Finally, when in doubt, use a pointer receiver.</li>
</ul>
<h2 id="synchronous-functions">Synchronous Functions</h2>
<p>Prefer synchronous functions - functions which return their results directly or finish any callbacks or channel ops before returning - over asynchronous ones.</p>
<p>Synchronous functions keep goroutines localized within a call, making it easier to reason about their lifetimes and avoid leaks and data races. They&rsquo;re also easier to test: the caller can pass an input and check the output without the need for polling or synchronization.</p>
<p>If callers need more concurrency, they can add it easily by calling the function from a separate goroutine. But it is quite difficult - sometimes impossible - to remove unnecessary concurrency at the caller side.</p>
<h2 id="useful-test-failures">Useful Test Failures</h2>
<p>Tests should fail with helpful messages saying what was wrong, with what inputs, what was actually got, and what was expected.  It may be tempting to write a bunch of assertFoo helpers, but be sure your helpers produce useful error messages.  Assume that the person debugging your failing test is not you, and is not your team.  A typical Go test fails like:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">got</span> <span class="o">!=</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">want</span> <span class="p">{</span>
	<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Foo(%q) = %d; want %d&#34;</span><span class="p">,</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">in</span><span class="p">,</span> <span class="nx">got</span><span class="p">,</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">want</span><span class="p">)</span> <span class="c1">// or Fatalf, if test can&#39;t test anything more past this point
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Note that the order here is actual != expected, and the message uses that order too. Some test frameworks encourage writing these backwards: 0 != x, &ldquo;expected 0, got x&rdquo;, and so on. Go does not.</p>
<p>If that seems like a lot of typing, you may want to write a [[table-driven test|TableDrivenTests]].</p>
<p>Another common technique to disambiguate failing tests when using a test helper with different input is to wrap each caller with a different TestFoo function, so the test fails with that name:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestSingleValue</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="nf">testHelper</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">80</span><span class="p">})</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">TestNoValues</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span>    <span class="p">{</span> <span class="nf">testHelper</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{})</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In any case, the onus is on you to fail with a helpful message to whoever&rsquo;s debugging your code in the future.</p>
<h2 id="variable-names">Variable Names</h2>
<p>变量名称应该尽可能的短。尤其是只在小范围使用短局部变量，例如 <code>c</code> 替换 <code>lineCount</code>。 <code>i</code> 替换 <code>sliceIndex</code></p>
<p>基本规则：使用变量名的地方距离声明它的地方越远，变量名描述的越具体。
对于方法的 receiver，一两个字母就够了。常见的变量，例如循环的下标和接收值的变量名，一个字母就够了（<code>i</code>, <code>r</code>）。其他不常用的或者全局变量，则需要描述的更具体一些。</p>

                        </div>

                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="/tags/go">Go</a></li>
                                
                                <li><a href="/tags/code-review">code review</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
                    <div id="comments"><span class="widget-title">评论已关闭</span></div>

                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        
    
<form id="search" method="POST" action="https://duckduckgo.com/">
    
    <input type="text" name="q" maxlength="255" placeholder="搜索...">
    
    <input type="hidden" name="sites" value="https://itsfinn.cc/">
    
    <input type="hidden" name="kp" value="-2">
    
    <input type="hidden" name="kh" value="1">
    
    <input type="hidden" name="kl" value="wt-wt">
    
    <input type="hidden" name="kg" value="p">
    
    <input type="hidden" name="kaf" value="1">
    
    
    <input type="hidden" name="k1" value="-1">

    

    
    
    <input type="hidden" name="k7" value="#ffffff">
    
    <input type="hidden" name="kj" value="#ffffff">
    
    <input type="hidden" name="ky" value="#eaeaea">
    
    <input type="hidden" name="kx" value="#6E7173">
    
    <input type="hidden" name="k8" value="#444">
    
    <input type="hidden" name="k9" value="#6E7173">
    
    <input type="hidden" name="kaa" value="#6E7173">
    
    <input type="hidden" name="kae" value="#6E7173">

    
    
    <input type="hidden" name="ko" value="1">
    
    <input type="hidden" name="kt" value="n">
    
    <input type="hidden" name="ka" value="g">
    
    <input type="hidden" name="ks" value="l">
    
    <input type="hidden" name="kv" value="1">

    <button type="submit" class="submit icon-search"></button>
</form>



    </section>

    <section class="widget">
        <h3 class="widget-title">分类</h3>
        <ul class="widget-list">
            
            <li>
                <a href="/categories/go">
                    go (1)
                </a>
            </li>
            
            <li>
                <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93">
                    数据库 (2)
                </a>
            </li>
            
        </ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
      &copy; 2021 <a rel="nofollow" href="https://itsfinn.cc/">itsfinn&#39;s blog.</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io">Hugo</a> &amp; <a rel="nofollow noreferer noopener" href="https://github.com/JokerQyou/maupassant-hugo">maupassant theme</a>.
    </div>
</footer>

<script type="text/javascript" src="/js/app.js" defer></script>

<script type="text/javascript" src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' defer></script>


</body>
</html>
